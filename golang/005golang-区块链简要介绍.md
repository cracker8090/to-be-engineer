[toc]

# 区块链本质
区块链本质是一种特殊的分布式数据库

![](https://raw.githubusercontent.com/cracker8090/imgbed/master/blogImg/20200901174915.png)
首先，区块链的主要作用是储存信息。任何需要保存的信息，都可以写入区块链，也可以从里面读取，所以它是数据库。

其次，任何人都可以架设服务器，加入区块链网络，成为一个节点。区块链的世界里面，没有中心节点，每个节点都是平等的，都保存着整个数据库。你可以向任何一个节点，写入/读取数据，因为所有节点最后都会同步，保证区块链一致。


分布式数据库很早就有了的，区块链没有管理员，它是彻底无中心的。其他的数据库都有管理员，但是区块链没有。如果有人想对区块链添加审核，也实现不了，因为它的设计目标就是防止出现居于中心地位的管理当局。

# 区块
区块链由一个个区块（block）组成。区块很像数据库的记录，每次写入数据，就是创建一个区块。

![](https://raw.githubusercontent.com/cracker8090/imgbed/master/blogImg/20200901175346.png)
每个区块包含两个部分
> - 区块头（Head）：记录当前区块的特征值
> - 区块体（Body）：实际数据

区块头包含了当前区块的多项特征值
> - 生成时间
> - 实际数据（即区块体）的哈希
> - 上一个区块的哈希
> - ...

所谓"哈希"就是计算机可以对任意内容，计算出一个长度相同的特征值。而且可以保证，只要原始内容不同，对应的哈希一定是不同的。
因此，就有两个重要的推论。
> - 推论1：每个区块的哈希都是不一样的，可以通过哈希标识区块。
> - 推论2：如果区块的内容变了，它的哈希一定会改变。

区块与哈希是一一对应的，每个区块的哈希都是针对"区块头"（Head）计算的。也就是说，把区块头的各项特征值，按照顺序连接在一起，组成一个很长的字符串，再对这个字符串计算哈希。
> Hash = SHA256( 区块头 )

如果当前区块体的内容变了，或者上一个区块的哈希变了，一定会引起当前区块的哈希改变。

这一点对区块链有重大意义。如果有人修改了一个区块，该区块的哈希就变了。为了让后面的区块还能连到它（因为下一个区块包含上一个区块的哈希），该人必须依次修改后面所有的区块，否则被改掉的区块就脱离区块链了。
哈希的计算很耗时，短时间内修改多个区块几乎不可能发生，除非有人掌握了全网51%以上的计算能力。
正是通过这种联动机制，区块链保证了自身的可靠性，数据一旦写入，就无法被篡改。
![区块链](https://raw.githubusercontent.com/cracker8090/imgbed/master/blogImg/20200901180429.png)

# 挖矿
由于必须保证节点之间的同步，所以新区块的添加速度不能太快。试想一下，你刚刚同步了一个区块，准备基于它生成下一个区块，但这时别的节点又有新区块生成，你不得不放弃做了一半的计算，再次去同步。因为每个区块的后面，只能跟着一个区块，你永远只能在最新区块的后面，生成下一个区块。所以，你别无选择，一听到信号，就必须立刻同步。

故意让添加新区块，变得很困难。他的设计是，平均每10分钟，全网才能生成一个新区块，一小时也就六个。
这种产出速度不是通过命令达成的，而是故意设置了海量的计算。也就是说，只有通过极其大量的计算，才能得到当前区块的有效哈希，从而把新区块添加到区块链。由于计算量太大，所以快不起来。

# 难度系数
原来不是任意一个哈希都可以，只有满足条件的哈希才会被区块链接受。这个条件特别苛刻，使得绝大部分哈希都不满足要求，必须重算。

原来，区块头包含一个难度系数（difficulty），这个值决定了计算哈希的难度。举例来说，第100000个区块的难度系数是 14484.16236122。

区块链协议规定，使用一个常量除以难度系数，可以得到目标值（target）。显然，难度系数越大，目标值就越小。

![](https://raw.githubusercontent.com/cracker8090/imgbed/master/blogImg/20200901181011.png)
哈希的有效性跟目标值密切相关，只有小于目标值的哈希才是有效的，否则哈希无效，必须重算。由于目标值非常小，哈希小于该值的机会极其渺茫，可能计算10亿次，才算中一次。这就是采矿如此之慢的根本原因。

前面说过，当前区块的哈希由区块头唯一决定。如果要对同一个区块反复计算哈希，就意味着，区块头必须不停地变化，否则不可能算出不一样的哈希。区块头里面所有的特征值都是固定的，为了让区块头产生变化，中本聪故意增加了一个随机项，叫做 Nonce。

Nonce 是一个随机值，矿工的作用其实就是猜出 Nonce 的值，使得区块头的哈希可以小于目标值，从而能够写入区块链。Nonce 是非常难猜的，目前只能通过穷举法一个个试错。根据协议，Nonce 是一个32位的二进制值，即最大可以到21.47亿。第 100000 个区块的 Nonce 值是274148111，可以理解成，矿工从0开始，一直计算了 2.74 亿次，才得到了一个有效的 Nonce 值，使得算出的哈希能够满足条件。

运气好的话，也许一会就找到了 Nonce。运气不好的话，可能算完了21.47亿次，都没有发现 Nonce，即当前区块体不可能算出满足条件的哈希。这时，协议允许矿工改变区块体，开始新的计算。

# 难度系数调节
为了将产出速率恒定在十分钟，中本聪还设计了难度系数的动态调节机制。他规定，难度系数每两周（2016个区块）调整一次。如果这两周里面，区块的平均生成速度是9分钟，就意味着比法定速度快了10%，因此接下来的难度系数就要调高10%；如果平均生成速度是11分钟，就意味着比法定速度慢了10%，因此接下来的难度系数就要调低10%。

难度系数越调越高（目标值越来越小），导致了采矿越来越难。


# 区块链分叉

如果两个人同时向区块链写入数据，同时有两个区块加入

![](https://raw.githubusercontent.com/cracker8090/imgbed/master/blogImg/20200901181724.png)
现在的规则是，新节点总是采用最长的那条区块链。如果区块链有分叉，将看哪个分支在分叉点后面，先达到6个新区块（称为"六次确认"）。按照10分钟一个区块计算，一小时就可以确认。
![](https://raw.githubusercontent.com/cracker8090/imgbed/master/blogImg/20200901181746.png)
由于新区块的生成速度由计算能力决定，所以这条规则就是说，拥有大多数计算能力的那条分支，就是正宗的区块链。


为了保证数据的可靠性，区块链也有自己的代价。一是效率，数据写入区块链，最少要等待十分钟，所有节点都同步数据，则需要更多的时间；二是能耗，区块的生成需要矿工进行无数无意义的计算，这是非常耗费能源的。

# 区块链的适用场景
- 不存在所有成员都信任的管理当局
- 写入的数据不要求实时使用
- 挖矿的收益能够弥补本身的成本



# 参考

1. typora有区块链文章：主要是geektime的总结（石墨文档备份）
2. [区块链入门教程](http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html) 